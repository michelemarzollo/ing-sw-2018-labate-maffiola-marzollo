package it.polimi.se2018.controller;

import it.polimi.se2018.model.*;
import it.polimi.se2018.model.events.Action;
import it.polimi.se2018.model.events.PlaceDie;
import it.polimi.se2018.model.events.SelectCard;
import it.polimi.se2018.model.events.ViewMessage;
import it.polimi.se2018.utils.Observer;

import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Base abstract class for game controllers.
 * <p>The class contains the basic game logic and some common
 * moves players can do.</p>
 * <p>Concrete subclasses have to implement the abstract methods
 * which allow to tweak the behavior of the above operations.</p>
 * <p>Subclasses can override the method {@code registerActions} to define
 * how the controller will react when a specified view event occurs.</p>
 * <p>Similarly, overriding the method {@code registerToolCardBehaviors}
 * custom tool cards can be registered.</p>
 * <p>This class is an {@code Observable<ViewMessage>} and its instances
 * have to be registered as observer to all the {@code Observable<ViewMessage>}
 * that are handled by that instance.</p>
 * <p>This class has no thread-safety yet.</p>
 */
public abstract class Controller implements Observer<ViewMessage> {

    /**
     * The game the controller is bound to.
     */
    private final Game game;

    /**
     * The dictionary which associates tool card names
     * to their behavior.
     */
    private final Map<String, ToolCardBehavior> toolCardBehaviors;

    /**
     * Map used to resolve requests by mapping each action to its
     * handler.
     */
    private final Map<Action, Consumer<ViewMessage>> actionMap;


    /**
     * Tells if the given tool card can be used.
     *
     * @param message The message generated by the view.
     * @return {@code true} if the specified tool card can be used;
     * {@code false} otherwise.
     */
    protected abstract boolean canUseToolCard(ViewMessage message);

    /**
     * Displays the correct game view.
     * @param message The message sent by the view.
     */
    protected abstract void displayGame(ViewMessage message);

    /**
     * Specifies how many dice have to be drafted when a new round is
     * set up.
     *
     * @return The amount of dice to be drafted at the beginning of a
     * new round.
     */
    protected abstract int getDraftAmount();

    /**
     * Consumes resources after the usage of a tool card.
     */
    protected abstract void consumeResources(ViewMessage message);

    /**
     * Fills the score board.
     */
    protected void fillScoreBoard(){
        List<Player> scoreboard = getGame().getPlayers().stream()
                .sorted((player1, player2) -> player2.getScore() - player1.getScore())
                .collect(Collectors.toList());
        getGame().setScoreBoard(scoreboard);
    }

    /**
     * Computes the score for each player.
     */
    protected abstract void calculateScores();

    /**
     * Register a new player in the game.
     * <p>When the maximum number of players is reached, it starts the game.</p>
     *
     * @param message The message generated by the view.
     */
    protected abstract void registerPlayer(ViewMessage message);

    /**
     * Creates a new controller associated to the specified game instance.
     *
     * @param game The game to be bound to the controller.
     */
    protected Controller(Game game) {
        this.game = game;
        toolCardBehaviors = new HashMap<>();
        registerToolCardBehaviors(toolCardBehaviors);

        actionMap = new HashMap<>();
        registerActions(actionMap);

    }

    /**
     * Allows to register custom tool card behaviors.
     *
     * @param behaviors The map containing the name-behavior pairs.
     */
    protected void registerToolCardBehaviors(Map<String, ToolCardBehavior> behaviors) {

        behaviors.put("Grozing Pliers", new GrozingPliersBehavior());
        behaviors.put("Eglomise Brush", new EglomiseBrushBehavior());
        behaviors.put("Copper Foil Burnisher", new CopperFoilBurnisherBehavior());
        behaviors.put("Lathekin", new LathekinBehavior());
        behaviors.put("Lens Cutter", new LensCutterBehaviour());
        behaviors.put("Flux Brush", new FluxBrushBehavior());
        behaviors.put("Glazing Hammer", new GlazingHammerBehavior());
        behaviors.put("Running Pliers", new RunningPliersBehaviour());
        behaviors.put("Cork-backed Straightedge", new CorkBackedSrtaighteddgeBehavior());
        behaviors.put("Grinding Stone", new GrindingStoneBehaviour());
        behaviors.put("Flux Remover", new FluxRemoverBehaviour());
        behaviors.put("Tap Wheel", new TapWheelBehavior());
    }

    /**
     * Allows to register custom action handlers.
     *
     * @param actions The map containing the name-handler pairs.
     */
    protected abstract void registerActions(Map<Action, Consumer<ViewMessage>> actions);

    /**
     * Detects what action {@code message} refers to and delegates the
     * registered method to handle it.
     *
     * @param message The message generated by the view.
     */
    protected void performAction(ViewMessage message) {
        Consumer<ViewMessage> action = actionMap.get(message.getAction());
        if (action != null)
            action.accept(message);
    }

    /**
     * Getter for game.
     *
     * @return The game the controller is bound to.
     */
    protected Game getGame() {
        return game;
    }

    /**
     * Entry point for events generated by the view.
     *
     * @param message The message generated by the view.
     */
    public final void update(ViewMessage message) {
        performAction(message);
    }

    protected Optional<Player> findPlayer(String playerName) {
        return getGame().getPlayers().stream()
                .filter(p -> p.getName().equals(playerName))
                .findFirst();

    }

    /**
     * Handles the end of the current turn and makes the game progress.
     * <p>If the current round has finished, it also starts a new one.</p>
     *
     * @param message The message generated by the view.
     */
    protected void endTurn(ViewMessage message) {
        boolean updateSuccessful = getGame().getTurnManager().updateTurn();
        if (!updateSuccessful)
            endRound(message);
    }

    /**
     * Tells if no more actions can be performed in the current turn.
     *
     * @return {@code true} if the current turn has no more possible
     * actions and can be safely ended; {@code false} otherwise.
     */
    protected boolean checkTurnEnd() {
        Turn currentTurn = getGame().getTurnManager().getCurrentTurn();
        return currentTurn.hasAlreadyPlacedDie() && currentTurn.hasAlreadyUsedToolCard();
    }

    /**
     * Handles the end of a round.
     * <p>If the game has finished, calls {@code endGame} to finalize
     * the match, otherwise sets up a new round and updates the current
     * turn.</p>
     *
     * @param message The message generated by the view.
     */
    protected void endRound(ViewMessage message) {
        try {
            getGame().getTurnManager().setupNewRound();
            refillDraftPool();
            getGame().getTurnManager().updateTurn();
        } catch (TurnManager.GameFinishedException e) {
            endGame(message);
        }
    }

    /**
     * Handles the end of the game.
     * <p>When the game ends, the draft pool is cleaned, the final
     * scores computed and the view is informed to display the
     * score board.</p>
     *
     * @param message The message generated by the view.
     */
    protected abstract void endGame(ViewMessage message);

    /**
     * Cleans the draft pool by moving leftovers to the round track.
     */
    protected void cleanDraftPool() {
        List<Die> leftovers = getGame().getDraftPool().getDice();
        int round = getGame().getTurnManager().getRound();
        getGame().getRoundTrack().addAllForRound(round, leftovers);
        getGame().getDraftPool().setDice(new ArrayList<>());
    }

    /**
     * Refills the draft pool with the dice drafted from the dice bag.
     * <p>The amount of dice drafted is specified by {@code getDraftAmount()}</p>
     */
    protected void refillDraftPool() {
        getGame().getDraftPool().setDice(
                getGame().getDiceBag().draft(getDraftAmount())
        );
    }

    /**
     * Helper method to check if the specified player can move this
     * turn.
     *
     * @param playerName The name of the player to be checked.
     * @return {@code true} if the player with the given name can move;
     * {@code false} otherwise.
     */
    protected boolean canMove(String playerName) {
        Turn currentTurn = getGame().getTurnManager().getCurrentTurn();
        return currentTurn.getPlayer().getName().equals(playerName);
    }

    /**
     * Places a die in the pattern of the player who made the move.
     * <p>It allows only the player who can currently move to perform a
     * placement. If any other player tries to make a move, he's notified
     * to wait.</p>
     * <p>If, after the placement, the current player can't make any other move,
     * his turn is automatically terminated.</p>
     *
     * @param message The message generated by the view.
     */
    protected void placeDie(ViewMessage message) {
        PlaceDie placeMessage = (PlaceDie) message;

        if (!canMove(placeMessage.getPlayerName())) {
            placeMessage.getView().showError("Not your turn!");
            return;
        }

        Turn currentTurn = getGame().getTurnManager().getCurrentTurn();
        if (currentTurn.hasAlreadyPlacedDie()) {
            placeMessage.getView().showError("You already placed a die!");
            return;
        }

        try {
            Die die = getGame().getDraftPool().select(placeMessage.getDieIndex());
            // place die
            Pattern currentPattern = currentTurn.getPlayer().getPattern();
            Pattern newPattern = currentPattern.placeDie(die, placeMessage.getDestination());
            currentTurn.getPlayer().setPattern(newPattern);

            getGame().getDraftPool().draft(placeMessage.getDieIndex());
            currentTurn.placeDie();
        } catch (IndexOutOfBoundsException e) {
            placeMessage.getView().showError("Invalid selection!");
        } catch (PlacementErrorException e) {
            placeMessage.getView().showError(
                    "Placement doesn't respect restrictions!\n" + e.getMessage()
            );
        }

        if (checkTurnEnd())
            endTurn(message);
    }

    /**
     * Asks the view to gather the parameters to use a given tool card.
     * <p>The method selects the correct behavior and delegates to it
     * the handling of parameter request.</p>
     *
     * @param message The message generated by the view.
     */
    protected void activateToolCard(ViewMessage message) {
        SelectCard selectMessage = (SelectCard) message;
        if (canUseToolCard(selectMessage)) {

            ToolCardBehavior behavior = toolCardBehaviors.get(message.getAction());
            if (behavior != null)
                behavior.askParameters(message);

        }
    }

    /**
     * Applies the effect of the given tool card.
     * <p>The method selects the correct behavior and delegates to it
     * the actual application of the effect to the model.</p>
     * <p>If, after the placement, the current player can't make any other move,
     * his turn is automatically terminated.</p>
     *
     * @param message The message generated by the view.
     */
    protected void applyToolCard(ViewMessage message) {
        //TODO check turn
        ToolCardBehavior behavior = toolCardBehaviors.get(message.getAction());

        if (behavior != null) {
            behavior.useToolCard(getGame(), message);
            getGame().getTurnManager().getCurrentTurn().useToolCard();
            consumeResources(message);
        }

        // return to game view
        displayGame(message);

        if (checkTurnEnd())
            endTurn(message);
    }

    /**
     * Handles the selection of a pattern among candidates by a player.
     * <p>If the specified player or pattern is invalid, the view is notified
     * of the error and nothing else happens. Otherwise, the player is updated
     * to use the given pattern.</p>
     * <p>After the assignment, it's checked if all the players have already
     * choose their pattern and, if so, the game starts.</p>
     *
     * @param message The message generated by the view.
     */
    protected void selectPattern(ViewMessage message) {
        SelectCard selectMessage = (SelectCard) message;

        Optional<Player> maybePlayer = findPlayer(selectMessage.getPlayerName());
        if (!maybePlayer.isPresent()) {
            selectMessage.getView().showError("Invalid player!");
            return;
        }

        Player player = maybePlayer.get();

        String patternName = selectMessage.getName();
        Pattern pattern = Arrays.stream(player.getCandidates())
                .filter(p -> p.getName().equals(patternName))
                .findFirst()
                .orElse(null);

        if (pattern == null) {
            selectMessage.getView().showError("Invalid pattern!");
            return;
        }

        player.setPattern(pattern);
        player.setTokens(pattern.getDifficulty());
        displayGame(message);

        boolean gameReady = getGame().getPlayers().stream()
                .allMatch(p -> p.getPattern() != null);

        if (gameReady)
            getGame().start();
    }

    /**
     * Disconnects a player.
     * <p>If the game has not yet began, the player is removed from the game,
     * but if the game has already been set up, his connection status is updated
     * to disconnected and won't be able to make moves until he reconnects.</p>
     *
     * @param message The message generated by the view.
     */
    protected abstract void disconnectPlayer(ViewMessage message);

    /**
     * Reconnects a disconnected player to the game.
     *
     * @param message The message generated by the view.
     */
    protected abstract void reconnectPlayer(ViewMessage message);


}
